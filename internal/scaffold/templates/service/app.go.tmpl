package app

import (
	"context"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/ranakdinesh/spur/config"
	"github.com/ranakdinesh/spur/httpserver"
	"github.comcom/ranakdinesh/spur/logger"

	{{- if .WithPostgres }}
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/ranakdinesh/spur/database/pgxkit"
	{{- end }}
	{{- if .WithRedis }}
	"github.com/redis/go-redis/v9"
	"github.com/ranakdinesh/spur/redis/rediskit"
	{{- end }}
	{{- if .WithAuth }}
	"github.com/ranakdinesh/spur/auth/authclient"
	{{- end }}
	{{- if .WithGRPC }}
	"github.com/ranakdinesh/spur/grpcserver"
	// The import below is for the example greeter service.
	// Replace or remove it when you add your own gRPC adapters/implementations
	// as per your hexagonal architecture (e.g., internal/adapters/grpc).
	// grpcapp "{{ .Module }}/internal/app/grpc"
	{{- end }}

	"go.opentelemetry.io/otel/trace"
)

// AppConfig holds all configuration for the application
type AppConfig struct {
	AppEnv                    string        `env:"APP_ENV" default:"development"`
	OtelExporterOTLPEndpoint  string        `env:"OTEL_EXPORTER_OTLP_ENDPOINT"`
	OtelServiceName           string        `env:"OTEL_SERVICE_NAME" default:"{{ .Name }}"`
	HTTPAddr                  string        `env:"HTTP_ADDR" default:":8080"`
	ReadTimeout               time.Duration `env:"HTTP_READ_TIMEOUT" default:"15s"`
	WriteTimeout              time.Duration `env:"HTTP_WRITE_TIMEOUT" default:"30s"`
	IdleTimeout               time.Duration `env:"HTTP_IDLE_TIMEOUT" default:"60s"`
	MaxBodyBytes              int64         `env:"HTTP_MAX_BODY_BYTES" default:"10485760"`
	EnableCORS                bool          `env:"HTTP_ENABLE_CORS" default:"true"`
	EnableSecurityHeaders     bool          `env:"HTTP_ENABLE_SECURITY_HEADERS" default:"true"`
	CORSAllowedOrigins        []string      `env:"CORS_ALLOWED_ORIGINS" default:"*" split:","`
	{{- if .WithGRPC }}
	GRPCAddr                  string        `env:"GRPC_ADDR" default:":9090"`
	{{- end }}
	{{- if .WithPostgres }}
	DatabaseURL               string        `env:"DATABASE_URL"`
	{{- end }}
	{{- if .WithRedis }}
	RedisAddr                 string        `env:"REDIS_ADDR"`
	{{- end }}
	{{- if .WithAuth }}
	OAuthIssuer               string        `env:"OAUTH_ISSUER"`
	OAuthAudience             string        `env:"OAUTH_AUDIENCE"`
	OAuthJWKSURL              string        `env:"O_AUTH_JWKS_URL"`
	{{- end }}
	LogServiceURL             string        `env:"LOG_SVC_URL"`
	LogServiceKey             string        `env:"LOG_SVC_API_KEY"`
}

// App holds all runtime dependencies for the application.
type App struct {
	Config       AppConfig
	Log          *logger.Loggerx
	HTTP         *httpserver.Server
	{{- if .WithGRPC }}
	GRPC         *grpcserver.Server
	{{- end }}
	{{- if .WithPostgres }}
	DB           *pgxpool.Pool
	{{- end }}
	{{- if .WithRedis }}
	RDB          *redis.Client
	{{- end }}
	{{- if .WithAuth }}
	Auth         *authclient.Validator
	{{- end }}
	TracerProvider trace.TracerProvider
	otelShutdown func(context.Context) error
}

// New creates a new App instance, initializing all dependencies.
func New(ctx context.Context) (*App, error) {
	// Load config
	cfg := AppConfig{}
	config.MustLoad(&cfg)

	// Logger
	prod := strings.ToLower(cfg.AppEnv) == "production"
	log := logger.NewWithOptions(logger.Options{
		Dev:            !prod,
		EnableHTTPSink: prod && cfg.LogServiceURL != "",
		HTTPURL:        cfg.LogServiceURL,
		HTTPAPIKey:     cfg.LogServiceKey,
		HTTPTimeout:    time.Second,
		Buffer:         2048,
	})
	log.Info(ctx).Msg("logger initialized")

	// Observability (Tracing)
	tp, shutdown, err := setupObservability(ctx, cfg.OtelServiceName, cfg.AppEnv, cfg.OtelExporterOTLPEndpoint)
	if err != nil {
		log.Error(ctx).Err(err).Msg("failed to setup observability")
		// Continue without tracing, but log the error
	} else {
		log.Info(ctx).Msg("observability initialized")
	}

	app := &App{
		Config:       cfg,
		Log:          log,
		TracerProvider: tp,
		otelShutdown: shutdown,
	}

	// Optional dependencies
	{{- if .WithPostgres }}
	if cfg.DatabaseURL != "" {
		p, err := pgxkit.NewPool(ctx, pgxkit.Options{DatabaseURL: cfg.DatabaseURL})
		if err != nil {
			log.Error(ctx).Err(err).Msg("db connect failed")
			// You might want to return err here instead of continuing
		} else {
			app.DB = p
			log.Info(ctx).Msg("db connected")
		}
	}
	{{- end }}

	{{- if .WithRedis }}
	if cfg.RedisAddr != "" {
		rr, err := rediskit.NewClient(ctx, rediskit.Options{Addr: cfg.RedisAddr})
		if err != nil {
			log.Error(ctx).Err(err).Msg("redis connect failed")
		} else {
			app.RDB = rr
			log.Info(ctx).Msg("redis connected")
		}
	}
	{{- end }}

	{{- if .WithAuth }}
	if cfg.OAuthIssuer != "" || cfg.OAuthJWKSURL != "" {
		vv, err := authclient.NewValidator(ctx, authclient.Options{
			Issuer:   cfg.OAuthIssuer,
			Audience: []string{cfg.OAuthAudience},
			JWKSURL:  cfg.OAuthJWKSURL,
		})
		if err != nil {
			log.Error(ctx).Err(err).Msg("auth validator init failed")
		} else {
			app.Auth = vv
		}
	}
	{{- end }}

	// Setup Servers
	app.setupHTTPServer()
	{{- if .WithGRPC }}
	if err := app.setupGRPCServer(ctx); err != nil {
		return nil, err
	}
	{{- end }}

	return app, nil
}

// setupHTTPServer configures the HTTP server and routes.
func (a *App) setupHTTPServer() {
	a.HTTP = httpserver.NewServer(httpserver.Options{
		Addr:                  a.Config.HTTPAddr,
		ReadTimeout:           a.Config.ReadTimeout,
		WriteTimeout:          a.Config.WriteTimeout,
		IdleTimeout:           a.Config.IdleTimeout,
		MaxBodyBytes:          a.Config.MaxBodyBytes,
		EnableCORS:            a.Config.EnableCORS,
		EnableSecurityHeaders: a.Config.EnableSecurityHeaders,
		AllowedOrigins:        a.Config.CORSAllowedOrigins,
		TracerProvider:        a.TracerProvider, // Pass the TracerProvider
	}, a.Log, a.registerHTTPRoutes) // Pass handler registration function
}

// registerHTTPRoutes sets up all http routes for the service
func (a *App) registerHTTPRoutes(r chi.Router) {
	// Public route (already added by NewServer, but good to know)
	// r.Get("/healthz", ...)

	// Wrap all app-specific routes and middleware in a group.
	// This prevents the panic by not adding middleware to the root
	// router after the /healthz routes have been defined.
	r.Group(func(r chi.Router) {
		{{- if .WithRedis }}
		if a.RDB != nil {
			r.Use(rediskit.IdempotencyMiddleware(a.RDB, rediskit.IdemOptions{
				TTL:        10 * time.Minute,
				HeaderName: "Idempotency-Key",
				MaxBody:    256 << 10,
			}))
		}
		{{- end }}

		// Register your HTTP adapters here, passing in dependencies
		//
		// Example:
		// userAdapter := adapters.NewUserHTTP(a.Log, a.DB)
		// r.Mount("/users", userAdapter.Routes())

		{{- if .WithAuth }}
		// Protected example using a handler method from an adapter
		r.Group(func(pr chi.Router) {
			pr.Use(authclient.HTTPAuth(a.Auth, authclient.Options{
				Issuer:       a.Config.OAuthIssuer,
				Audience:     []string{a.Config.OAuthAudience},
				APIKeyHeader: "X-API-Key",
				APIKeyValue:  "",
			}, a.Log))

			// This is where you would mount protected routes
			//
			// Example:
			// meAdapter := adapters.NewMeHTTP(a.Log, a.DB)
			// pr.Get("/me", meAdapter.GetSelf)
		})
		{{- end }}
	})
}


{{- if .WithGRPC }}
// setupGRPCServer configures the gRPC server.
func (a *App) setupGRPCServer(ctx context.Context) error {
	// Build gRPC server
	gsv, err := grpcserver.New(grpcserver.Options{
		Addr:             a.Config.GRPCAddr,
		Log:              a.Log,
		{{- if .WithAuth }}
		// Pass the interceptor function created from the validator
		// This assumes 'grpcserver.Options' has a field 'Auth'
		// that expects the interceptor function.
		Auth:             authclient.UnaryServerInterceptor(a.Auth),
		{{- end }}
		TracerProvider:   a.TracerProvider,
		EnableHealth:     true,
		EnableReflection: true,
	}, func(r grpcserver.GRPCRegistrar) {
		// Register gRPC services here, passing in app dependencies
		// This is where you would import your `internal/adapters/grpc` package
		// and register your implementations.
		//
		// Example:
		// myAdapter := adapters.NewMyService(a.Log, a.DB)
		// pb.RegisterMyServiceServer(r, myAdapter)

		// The line below is a placeholder from the template.
		// You can safely remove it.
		// grpcapp.RegisterGrgRPCeeterService(r, a.Log, a.DB)
	})

	if err != nil {
		a.Log.Error(ctx).Err(err).Msg("grpc build failed")
		return err
	}
	a.GRPC = gsv
	return nil
}
{{- end }}

