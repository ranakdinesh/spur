package app

import (
	"context"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/ranakdinesh/spur/config"
	"github.com/ranakdinesh/spur/httpserver"
	"github.com/ranakdinesh/spur/logger"

	{{- if .WithPostgres }}
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/ranakdinesh/spur/database/pgxkit"
	{{- end }}
	{{- if .WithRedis }}
	"github.com/redis/go-redis/v9"
	"github.com/ranakdinesh/spur/redis/rediskit"
	{{- end }}
	{{- if .WithAuth }}
	"github.com/ranakdinesh/spur/auth/authclient"
	{{- end }}
	{{- if .WithGRPC }}
	"github.com/ranakdinesh/spur/grpcserver"
		{{- if .WithAuth }}
		// Imports needed for the gRPC auth adapter
		"google.golang.org/grpc/codes"
		"google.golang.org/grpc/status"
		{{- end }}
	{{- end }}

	// "go.opentelemetry.io/otel"
	// "go.opentelemetry.io/otel/trace"
)

// AppConfig holds all configuration for the application
type AppConfig struct {
	AppEnv                    string        `env:"APP_ENV" default:"development"`
	OtelServiceName           string        `env:"OTEL_SERVICE_NAME" default:"{{ .Name }}"`
	OtelExporterEndpoint      string        `env:"OTEL_EXPORTER_OTLP_ENDPOINT"`
	HTTPAddr                  string        `env:"HTTP_ADDR" default:":8080"`
	{{- if .WithGRPC }}
	GRPCAddr                  string        `env:"GRPC_ADDR" default:":9090"`
	{{- end }}
	ReadTimeout               time.Duration `env:"HTTP_READ_TIMEOUT" default:"15s"`
	WriteTimeout              time.Duration `env:"HTTP_WRITE_TIMEOUT" default:"30s"`
	IdleTimeout               time.Duration `env:"HTTP_IDLE_TIMEOUT" default:"60s"`
	MaxBodyBytes              int64         `env:"HTTP_MAX_BODY_BYTES" default:"10485760"`
	EnableCORS                bool          `env:"HTTP_ENABLE_CORS" default:"true"`
	EnableSecurityHeaders     bool          `env:"HTTP_ENABLE_SECURITY_HEADERS" default:"true"`
	CORSAllowedOrigins        []string      `env:"CORS_ALLOWED_ORIGINS" default:"*" split:","`
	{{- if .WithPostgres }}
	DatabaseURL               string        `env:"DATABASE_URL"`
	{{- end }}
	{{- if .WithRedis }}
	RedisAddr                 string        `env:"REDIS_ADDR"`
	{{- end }}
	{{- if .WithAuth }}
	OAuthIssuer               string        `env:"OAUTH_ISSUER"`
	OAuthAudience             string        `env:"OAUTH_AUDIENCE"`
	OAuthJWKSURL              string        `env:"OAUTH_JWKS_URL"`
	APIKeyHeader              string        `env:"API_KEY_HEADER"`
	APIKeyValue               string        `env:"API_KEY_VALUE"`
	{{- end }}
	LogServiceURL             string        `env:"LOG_SVC_URL"`
	LogServiceKey             string        `env:"LOG_SVC_API_KEY"`
}

// App holds all runtime dependencies for the application.
type App struct {
	Config   AppConfig
	Log      *logger.Loggerx
	HTTP     *httpserver.Server
	// Tracer   trace.Tracer
	{{- if .WithGRPC }}
	GRPC     *grpcserver.Server
	{{- end }}
	{{- if .WithPostgres }}
	DB       *pgxpool.Pool
	{{- end }}
	{{- if .WithRedis }}
	RDB      *redis.Client
	{{- end }}
	{{- if .WithAuth }}
	Auth     *authclient.Validator
	{{- end }}
}

// New creates a new App instance, initializing all dependencies.
func New(ctx context.Context) (*App, error) {
	// Load config
	cfg := AppConfig{}
	config.MustLoad(&cfg)

	// Logger
	prod := strings.ToLower(cfg.AppEnv) == "production"
	log := logger.NewWithOptions(logger.Options{
		Dev:            !prod,
		EnableHTTPSink: prod && cfg.LogServiceURL != "",
		HTTPURL:        cfg.LogServiceURL,
		HTTPAPIKey:     cfg.LogServiceKey,
		HTTPTimeout:    time.Second,
		Buffer:         2048,
	})
	log.Info(ctx).Msg("logger initialized")

	// // Tracer
	// tp, err := initOtel(ctx, cfg.OtelExporterEndpoint, cfg.OtelServiceName, cfg.AppEnv)
	// if err != nil {
	// 	log.Error(ctx).Err(err).Msg("failed to initialize opentelemetry")
	// }
	// tracer := tp.Tracer(cfg.OtelServiceName)
	// // Set global tracer provider
	// otel.SetTracerProvider(tp)
	// log.Info(ctx).Msg("tracer initialized")


	app := &App{
		Config:   cfg,
		Log:      log,
		// Tracer:   tracer,
	}

	// Optional dependencies
	{{- if .WithPostgres }}
	if cfg.DatabaseURL != "" {
		p, err := pgxkit.NewPool(ctx, pgxkit.Options{DatabaseURL: cfg.DatabaseURL})
		if err != nil {
			log.Error(ctx).Err(err).Msg("db connect failed")
			// You might want to return err here instead of continuing
		} else {
			app.DB = p
			log.Info(ctx).Msg("db connected")
		}
	}
	{{- end }}

	{{- if .WithRedis }}
	if cfg.RedisAddr != "" {
		rr, err := rediskit.NewClient(ctx, rediskit.Options{Addr: cfg.RedisAddr})
		if err != nil {
			log.Error(ctx).Err(err).Msg("redis connect failed")
		} else {
			app.RDB = rr
			log.Info(ctx).Msg("redis connected")
		}
	}
	{{- end }}

	{{- if .WithAuth }}
	if cfg.OAuthIssuer != "" || cfg.OAuthJWKSURL != "" {
		vv, err := authclient.NewValidator(ctx, authclient.Options{
			Issuer:   cfg.OAuthIssuer,
			Audience: []string{cfg.OAuthAudience},
			JWKSURL:  cfg.OAuthJWKSURL,
		})
		if err != nil {
			log.Error(ctx).Err(err).Msg("auth validator init failed")
		} else {
			app.Auth = vv
		}
	}
	{{- end }}

	// Setup Servers
	app.setupHTTPServer(ctx)

	{{- if .WithGRPC }}
	if err := app.setupGRPCServer(ctx); err != nil {
		return nil, err
	}
	{{- end }}

	return app, nil
}

// setupHTTPServer configures the HTTP server and routes.
func (a *App) setupHTTPServer(ctx context.Context) {
	a.HTTP = httpserver.NewServer(httpserver.Options{
		Addr:                  a.Config.HTTPAddr,
		ReadTimeout:           a.Config.ReadTimeout,
		WriteTimeout:          a.Config.WriteTimeout,
		IdleTimeout:           a.Config.IdleTimeout,
		MaxBodyBytes:          a.Config.MaxBodyBytes,
		EnableCORS:            a.Config.EnableCORS,
		EnableSecurityHeaders: a.Config.EnableSecurityHeaders,
		AllowedOrigins:        a.Config.CORSAllowedOrigins,
		// TracerProvider:        otel.GetTracerProvider(), // Pass the global tracer
	}, a.Log, a.registerHTTPRoutes) // Pass the route registration func
}

// registerHTTPRoutes contains all the application-specific routes.
// This is passed as the MountFunc to the httpserver.
func (a *App) registerHTTPRoutes(r chi.Router) {
	// Wrap all app routes in a group.
	// This ensures middlewares (like idempotency) are added *before* routes.
	r.Group(func(r chi.Router) {
		{{- if .WithRedis }}
		if a.RDB != nil {
			// Example: Idempotency middleware
			r.Use(rediskit.IdempotencyMiddleware(a.RDB, rediskit.IdemOptions{
				TTL:        10 * time.Minute,
				HeaderName: "Idempotency-Key",
				MaxBody:    256 << 10, // 256KB
			}))
		}
		{{- end }}

		{{- if .WithAuth }}
		// --- PROTECTED ROUTES ---
		r.Group(func(pr chi.Router) {
			// This is the HTTP Auth middleware from your spur library
			pr.Use(authclient.HTTPAuth(a.Auth, authclient.Options{
				APIKeyHeader: a.Config.APIKeyHeader,
				APIKeyValue:  a.Config.APIKeyValue,
			}, a.Log))

			// --- ADAPTER REGISTRATION ---
			// Register your protected HTTP service adapters (handlers) here.
			// Example:
			// userHandler := httpadapter.NewUserHandler(a.Log, a.DB)
			// pr.Mount("/users", userHandler.Routes())
			// ----------------------------
		})
		{{- end }}

		// --- PUBLIC ROUTES ---
		// Register public HTTP service adapters (handlers) here.
		// Example:
		// pr.Get("/some-public-endpoint", myHandler.GetPublicData)
		// ----------------------------
	})
}


{{- if .WithGRPC }}
// setupGRPCServer configures the gRPC server.
func (a *App) setupGRPCServer(ctx context.Context) error {
    // Build server options
    opt := grpcserver.Options{
        Addr: a.Config.GRPCAddr,
        Log:  a.Log,
        // TracerProvider: otel.GetTracerProvider(), // optional
    }

    {{- if .WithAuth }}
    // When auth is enabled, wire validator and context enricher
    if a.Auth != nil {
        validate := func(token string) (*grpcserver.Claims, error) {
            claims, err := a.Auth.Validate(context.Background(), token)
            if err != nil {
                a.Log.Warn(ctx).Err(err).Msg("gRPC auth validation failed")
                return nil, status.Error(codes.Unauthenticated, "unauthorized")
            }
            return &grpcserver.Claims{
                Subject:  claims.Subject,
                TenantID: claims.TenantID,
                Scope:    claims.Scope,
                Raw:      nil,
            }, nil
        }

        enricher := func(ctx context.Context, token string, c grpcserver.Claims) context.Context {
            ctx = authclient.WithToken(ctx, token)
            if c.Subject != "" {
                ctx = authclient.WithSubject(ctx, c.Subject)
                ctx = logger.WithUserID(ctx, c.Subject)
            }
            if c.TenantID != "" {
                ctx = authclient.WithTenantID(ctx, c.TenantID)
                ctx = logger.WithTenantID(ctx, c.TenantID)
            }
            if len(c.Scope) > 0 {
                ctx = authclient.WithScopes(ctx, c.Scope)
            }
            return ctx
        }

        opt.ValidateToken = validate
        opt.APIKeyHeader = a.Config.APIKeyHeader
        opt.AllowUnAuthenticated = []string{"/grpc.health.v1.Health/*", "/grpc.reflection.v1alpha.ServerReflection/*"}
        opt.EnrichContext = enricher
    }
    {{- end }}

    gsv, err := grpcserver.New(opt, func(r grpcserver.GRPCRegistrar) {
        // --- ADAPTER REGISTRATION ---
        // Register your gRPC service adapters here.
        // Example:
        // myAdapter := grpcadapter.New(a.Log, a.DB)
        // pb.RegisterGreeterService(r, myAdapter)
        // ----------------------------
    })
    if err != nil {
        return err
    }
    a.GRPC = gsv
    return nil
}
{{- end }}

