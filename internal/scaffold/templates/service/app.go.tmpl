package app

import (
	"context"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/ranakdinesh/spur/config"
	"github.com/ranakdinesh/spur/httpserver"
	"github.com/ranakdinesh/spur/logger"

	{{- if .WithPostgres }}
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/ranakdinesh/spur/database/pgxkit"
	{{- end }}
	{{- if .WithRedis }}
	"github.com/redis/go-redis/v9"
	"github.com/ranakdinesh/spur/redis/rediskit"
	{{- end }}
	{{- if .WithAuth }}
	"github.com/ranakdinesh/spur/auth/authclient"
	{{- end }}
	{{- if .WithGRPC }}
	"github.com/ranakdinesh/spur/grpcserver"
		{{- if .WithAuth }}
		// Imports needed for the gRPC auth adapter
		"google.golang.org/grpc/codes"
		"google.golang.org/grpc/status"
		{{- end }}
	{{- end }}

	// "go.opentelemetry.io/otel"
	// "go.opentelemetry.io/otel/trace"
)

// AppConfig holds all configuration for the application
type AppConfig struct {
	AppEnv                    string        `env:"APP_ENV" default:"development"`
	OtelServiceName           string        `env:"OTEL_SERVICE_NAME" default:"{{ .Name }}"`
	OtelExporterEndpoint      string        `env:"OTEL_EXPORTER_OTLP_ENDPOINT"`
	HTTPAddr                  string        `env:"HTTP_ADDR" default:":8080"`
	{{- if .WithGRPC }}
	GRPCAddr                  string        `env:"GRPC_ADDR" default:":9090"`
	{{- end }}
	ReadTimeout               time.Duration `env:"HTTP_READ_TIMEOUT" default:"15s"`
	WriteTimeout              time.Duration `env:"HTTP_WRITE_TIMEOUT" default:"30s"`
	IdleTimeout               time.Duration `env:"HTTP_IDLE_TIMEOUT" default:"60s"`
	MaxBodyBytes              int64         `env:"HTTP_MAX_BODY_BYTES" default:"10485760"`
	EnableCORS                bool          `env:"HTTP_ENABLE_CORS" default:"true"`
	EnableSecurityHeaders     bool          `env:"HTTP_ENABLE_SECURITY_HEADERS" default:"true"`
	CORSAllowedOrigins        []string      `env:"CORS_ALLOWED_ORIGINS" default:"*" split:","`
	{{- if .WithPostgres }}
	DatabaseURL               string        `env:"DATABASE_URL"`
	{{- end }}
	{{- if .WithRedis }}
	RedisAddr                 string        `env:"REDIS_ADDR"`
	{{- end }}
	{{- if .WithAuth }}
	OAuthIssuer               string        `env:"OAUTH_ISSUER"`
	OAuthAudience             string        `env:"OAUTH_AUDIENCE"`
	OAuthJWKSURL              string        `env:"OAUTH_JWKS_URL"`
	APIKeyHeader              string        `env:"API_KEY_HEADER"`
	APIKeyValue               string        `env:"API_KEY_VALUE"`
	{{- end }}
	LogServiceURL             string        `env:"LOG_SVC_URL"`
	LogServiceKey             string        `env:"LOG_SVC_API_KEY"`
}

// App holds all runtime dependencies for the application.
type App struct {
	Config   AppConfig
	Log      *logger.Loggerx
	HTTP     *httpserver.Server
	// Tracer   trace.Tracer
	{{- if .WithGRPC }}
	GRPC     *grpcserver.Server
	{{- end }}
	{{- if .WithPostgres }}
	DB       *pgxpool.Pool
	{{- end }}
	{{- if .WithRedis }}
	RDB      *redis.Client
	{{- end }}
	{{- if .WithAuth }}
	Auth     *authclient.Validator
	{{- end }}
}

// New creates a new App instance, initializing all dependencies.
func New(ctx context.Context) (*App, error) {
	// Load config
	cfg := AppConfig{}
	config.MustLoad(&cfg)

	// Logger
	prod := strings.ToLower(cfg.AppEnv) == "production"
	log := logger.NewWithOptions(logger.Options{
		Dev:            !prod,
		EnableHTTPSink: prod && cfg.LogServiceURL != "",
		HTTPURL:        cfg.LogServiceURL,
		HTTPAPIKey:     cfg.LogServiceKey,
		HTTPTimeout:    time.Second,
		Buffer:         2048,
	})
	log.Info(ctx).Msg("logger initialized")

	// // Tracer
	// tp, err := initOtel(ctx, cfg.OtelExporterEndpoint, cfg.OtelServiceName, cfg.AppEnv)
	// if err != nil {
	// 	log.Error(ctx).Err(err).Msg("failed to initialize opentelemetry")
	// }
	// tracer := tp.Tracer(cfg.OtelServiceName)
	// // Set global tracer provider
	// otel.SetTracerProvider(tp)
	// log.Info(ctx).Msg("tracer initialized")


	app := &App{
		Config:   cfg,
		Log:      log,
		// Tracer:   tracer,
	}

	// Optional dependencies
	{{- if .WithPostgres }}
	if cfg.DatabaseURL != "" {
		p, err := pgxkit.NewPool(ctx, pgxkit.Options{DatabaseURL: cfg.DatabaseURL})
		if err != nil {
			log.Error(ctx).Err(err).Msg("db connect failed")
			// You might want to return err here instead of continuing
		} else {
			app.DB = p
			log.Info(ctx).Msg("db connected")
		}
	}
	{{- end }}

	{{- if .WithRedis }}
	if cfg.RedisAddr != "" {
		rr, err := rediskit.NewClient(ctx, rediskit.Options{Addr: cfg.RedisAddr})
		if err != nil {
			log.Error(ctx).Err(err).Msg("redis connect failed")
		} else {
			app.RDB = rr
			log.Info(ctx).Msg("redis connected")
		}
	}
	{{- end }}

	{{- if .WithAuth }}
	if cfg.OAuthIssuer != "" || cfg.OAuthJWKSURL != "" {
		vv, err := authclient.NewValidator(ctx, authclient.Options{
			Issuer:   cfg.OAuthIssuer,
			Audience: []string{cfg.OAuthAudience},
			JWKSURL:  cfg.OAuthJWKSURL,
		})
		if err != nil {
			log.Error(ctx).Err(err).Msg("auth validator init failed")
		} else {
			app.Auth = vv
		}
	}
	{{- end }}

	// Setup Servers
	app.setupHTTPServer(ctx)

	{{- if .WithGRPC }}
	if err := app.setupGRPCServer(ctx); err != nil {
		return nil, err
	}
	{{- end }}

	return app, nil
}

// setupHTTPServer configures the HTTP server and routes.
func (a *App) setupHTTPServer(ctx context.Context) {
	a.HTTP = httpserver.NewServer(httpserver.Options{
		Addr:                  a.Config.HTTPAddr,
		ReadTimeout:           a.Config.ReadTimeout,
		WriteTimeout:          a.Config.WriteTimeout,
		IdleTimeout:           a.Config.IdleTimeout,
		MaxBodyBytes:          a.Config.MaxBodyBytes,
		EnableCORS:            a.Config.EnableCORS,
		EnableSecurityHeaders: a.Config.EnableSecurityHeaders,
		AllowedOrigins:        a.Config.CORSAllowedOrigins,
		// TracerProvider:        otel.GetTracerProvider(), // Pass the global tracer
	}, a.Log, a.registerHTTPRoutes) // Pass the route registration func
}

// registerHTTPRoutes contains all the application-specific routes.
// This is passed as the MountFunc to the httpserver.
func (a *App) registerHTTPRoutes(r chi.Router) {
	// Wrap all app routes in a group.
	// This ensures middlewares (like idempotency) are added *before* routes.
	r.Group(func(r chi.Router) {
		{{- if .WithRedis }}
		if a.RDB != nil {
			// Example: Idempotency middleware
			r.Use(rediskit.IdempotencyMiddleware(a.RDB, rediskit.IdemOptions{
				TTL:        10 * time.Minute,
				HeaderName: "Idempotency-Key",
				MaxBody:    256 << 10, // 256KB
			}))
		}
		{{- end }}

		{{- if .WithAuth }}
		// --- PROTECTED ROUTES ---
		r.Group(func(pr chi.Router) {
			// This is the HTTP Auth middleware from your spur library
			pr.Use(authclient.HTTPAuth(a.Auth, authclient.Options{
				APIKeyHeader: a.Config.APIKeyHeader,
				APIKeyValue:  a.Config.APIKeyValue,
			}, a.Log))

			// --- ADAPTER REGISTRATION ---
			// Register your protected HTTP service adapters (handlers) here.
			// Example:
			// userHandler := httpadapter.NewUserHandler(a.Log, a.DB)
			// pr.Mount("/users", userHandler.Routes())
			// ----------------------------
		})
		{{- end }}

		// --- PUBLIC ROUTES ---
		// Register public HTTP service adapters (handlers) here.
		// Example:
		// pr.Get("/some-public-endpoint", myHandler.GetPublicData)
		// ----------------------------
	})
}


{{- if .WithGRPC }}
// setupGRPCServer configures the gRPC server.
func (a *App) setupGRPCServer(ctx context.Context) error {
	// --- ADAPTER FUNCTION ---
	// This function bridges the gap between authclient.Validator and grpcserver.UnaryAuthFunc

	{{- if .WithAuth }}
	var authFunc grpcserver.UnaryAuthFunc // <-- MOVED DECLARATION INSIDE
	if a.Auth != nil {
		authFunc = func(ctx context.Context, token string) (context.Context, error) {
			// Use the validator to validate the token
			claims, err := a.Auth.Validate(ctx, token)
			if err != nil {
				a.Log.Warn(ctx).Err(err).Msg("gRPC auth validation failed")
				return nil, status.Error(codes.Unauthenticated, "unauthorized") // Use codes.Unauthenticated
			}

			// On success, enrich the context
			ctx = authclient.WithToken(ctx, token)
			if claims.Subject != "" {
				ctx = authclient.WithSubject(ctx, claims.Subject)
				ctx = logger.WithUserID(ctx, claims.Subject) // Also enrich logger
			}
			if claims.TenantID != "" {
				ctx = authclient.WithTenantID(ctx, claims.TenantID)
				ctx = logger.WithTenantID(ctx, claims.TenantID) // Also enrich logger
			}
			if len(claims.Scope) > 0 {
				ctx = authclient.WithScopes(ctx, claims.Scope)
			}
			return ctx, nil
		}
	}
	{{- end }}
	// --- END ADAPTER ---

	gsv, err := grpcserver.New(grpcserver.Options{
		Addr:           a.Config.GRPCAddr,
		Log:            a.Log,
		// TracerProvider: otel.GetTracerProvider(), // Pass the global tracer
		{{- if .WithAuth }}
		Auth:           authFunc, // Pass the adapter function
		{{- end }}
	}, func(r grpcserver.GRPCRegistrar) {
		// --- ADAPTER REGISTRATION ---
		// Register your gRPC service adapters here.
		// Example:
		// myAdapter := grpcadapter.New(a.Log, a.DB)
		// pb.RegisterGreeterService(r, myAdapter)
		// ----------------------------
	})
	if err != nil {
		return err
	}
	a.GRPC = gsv
	return nil
}
{{- end }}

